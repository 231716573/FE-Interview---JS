1.用JS将字符串 '[{"a":"1", "b":"2", "c":"3"}]' 转为数组，然后弹出a下面的1.

  答案1： var str = "[{'a':'1', 'b':'2' , 'c': '3'}]";
        str = eval("("+str+")")
        console.log(str[0].a)
      

2. a++ 与 ++a 区别
  var a=10, b=20, c=30;
  ++a;  // 11
  a++;  // 11
  e = ++a+(++b)+(c++)+a++; // 13+(21)+(30)+13;
  console.log(e);  //77

3.变量提升以及函数作用域
  3.1
    f1()
    console.log("."+a); // 报错，提示 a is not defined
    console.log("."+b);
    console.log("."+c);
    function f1(){
        var a=b=c=9;
        console.log(a); // 9
        console.log(b); // 9
        console.log(c); // 9
    }
  3.2
    var a = 18;
    f1();
    function f1(){
        var b = 9;
        console.log(a);  // undefined
        console.log(b);  // 9;
        var a = '123';
    }

4.题目：填写内容让下面代码支持a.name = “name1”; b.name = “name2”;
function obj(name){
    _______
}
obj._____ = "name2";
var a = obj("name1");
var b = new obj;

答案：//创建全局函数
    function obj(name){
         if(name) {        // 区分普通调用和实例化调用
            this.name = name;
          }
          return this;    // 返回this引用，调用时this指向window
    }

    obj.prototype.name = "name2";    // 设置原型对象
    var a = obj("name1");    //直接调用函数，a等于window，name为window的属性。
    var b = new obj;    //调用函数实例化对象，this指向obj的实例化对象。
    
    
5.

1、person1.__proto__ 是什么？
2、Person.__proto__ 是什么？
3、Person.prototype.__proto__ 是什么？
4、Object.__proto__ 是什么？
5、Object.prototype__proto__ 是什么？

答案：
第一题：
因为 person1.__proto__ === person1 的构造函数.prototype
因为 person1的构造函数 === Person
所以 person1.__proto__ === Person.prototype

第二题：
因为 Person.__proto__ === Person的构造函数.prototype
因为 Person的构造函数 === Function
所以 Person.__proto__ === Function.prototype

第三题：
Person.prototype 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。
因为一个普通对象的构造函数 === Object
所以 Person.prototype.__proto__ === Object.prototype

第四题，参照第二题，因为 Person 和 Object 一样都是构造函数
                Object.__proto__ == Function.prototype

第五题：
Object.prototype 对象也有proto属性，但它比较特殊，为 null 。因为 null 处于原型链的顶端，这个只能记住。
Object.prototype.__proto__ === null

原型链例子：
function Person(){}
var person1 = new Person();
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype) //true
console.log(Object.prototype.__proto__) //null

Person.__proto__ == Function.prototype; //true
console.log(Function.prototype)// function(){} (空函数)

var num = new Array()
console.log(num.__proto__ == Array.prototype) // true
console.log( Array.prototype.__proto__ == Object.prototype) // true
console.log(Array.prototype) // [] (空数组)
console.log(Object.prototype.__proto__) //null

console.log(Array.__proto__ == Function.prototype)// true

疑点解惑：
1、Object.__proto__ === Function.prototype // true
Object 是函数对象，是通过new Function()创建的，所以Object.__proto__指向Function.prototype。（参照第八小节：「所有函数对象的__proto__都指向Function.prototype」）

2、Function.__proto__ === Function.prototype // true
Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。

3、Function.prototype.__proto__ === Object.prototype //true
其实这一点我也有点困惑，不过也可以试着解释一下。
Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。
JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.__proto__ === null，保证原型链能够正常结束。




6.建立一个function,接受参数n=5,不用for循环输出数组【1,2,3,4,5】

function show(n) {
    var arr = [];
    return (function fn() {
        arr.unshift(n);
        n--;
        if (n != 0) {
            fn();
        }
        return arr;

    })()
}
show(5)//[1,2,3,4,5]


7.判断类型
console.log(typeof(null))        //object
console.log(typeof(undefined))   //undefined
console.log(typeof(Number))      //function
console.log(typeof(String))      //function
console.log(typeof(NaN))         //number
console.log(typeof(object))      //undefined
var str = 'abc'
console.log(typeof(str++))       //number
console.log(str)                 //NaN
console.log(NaN==undefined);     //false
console.log(NaN==NaN);           //false
